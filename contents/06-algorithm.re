= アルゴリズム とは
//abstract{
  アルゴリズムとは、「計算や作業を遂行するための手順」のことです。良いプログラムを作る上で、アルゴリズムの理解は欠かせません。
  有名なアルゴリズムの紹介とともに、その表現に良く用いられる「流れ図」や「効率性」の考察も行います。
//}

== アルゴリズムとは
語源は、九世紀前半を生きたアラビアの数学者アル・フワーリズミーに因みます。日本語では「算法」と訳されます。

アルゴリズムとは、@<B>{「計算や作業を遂行するための手順」} @<fn>{1} のことです。
並び替えや探索など基本的なものから、素数判定、最大公約数、円周率の計算など、数学的なもの、分類分け、データ圧縮などなど、さまざまなアルゴリズムが考案されてきました。

//footnote[1][出典: アルゴリズム図鑑]

=== ユークリッドの互除法
//sideimage[Euclidean][30mm][sep=5mm]{
紀元前300年頃に記されたユークリッドの『原論』に記されている世界最古のアルゴリズムである。
2つの自然数(1071と1029)の最大公約数を求める例を挙げる。1071 を 1029 で割った余りは 42。1029 を 42 で割った余りは 21。42 を 21 で割った余りは 0。よって、最大公約数は21である。として簡単に求めることが出来る。
それぞれの自然数を素因数分解しても最大公約数を求めることができるが、ユークリッドの互除法を用いると格段に速く計算可能である。

@<small>{(「ラメの定理」により、割って余りを取る操作を、最悪でも小さい十進数の桁数の約5倍繰り返せば、最大公約数に達する。)}
//}

=== エラトステネスの @<ruby>{篩,ふるい}
//sideimage[Eratosthenes][50mm][sep=5mm]{
古代ギリシアの科学者エラトステネスが考案した、指定された整数以下の全ての素数を発見するための単純なアルゴリズム。100までの素数を見つける場合、図のように2から100までの数を篩に入れておく。次に篩の中で最小の数2は素数の為、その倍数を篩い落とす、残った数の中で最小の数3は素数の為、その倍数を篩い落とす。これを順に繰り返していき、11(√100より大きな最初の素数)に達した時点で、篩に残っていた全ての数は素数である。
また、地球の大きさを最初に測定したことでも知られている。
//}

=== ハノイの塔
//sideimage[Hanoi][50mm][sep=5mm]{
パズルの一種。三本の杭と、大きさの異なる複数の円盤があり、左端の杭に小さいものが上になるように順に積み重ねられている。円盤を一回に一枚ずつどれかの杭に移動させることができるが、小さな円盤の上に大きな円盤を乗せることはできない。右端の杭に全ての円盤を移動させよ。
//}

=== ナップサック問題
//sideimage[knapsack][50mm][sep=5mm]{
「袋には15kgまで入れられる。重量や価値の異なる様々な品があるが、袋の価値を最大化するためには、どの品を詰めたら良いか？」という問題で、計算複雑性理論に於て、NP困難と呼ばれる問題のクラスに属する。動的計画法を用いた擬多項式時間アルゴリズムにより、実用的にはほぼ最適な解が得られる。
//}
//vspace[latex][2mm]
貪慾法と呼ばれるアルゴリズムでの解答例を示す。「貪慾」という名前の通り、各荷物の評価値(=価格÷重量)を算出し、評価値の高いものからナップサックに入れていくのが骨子である。
①の品は価値が2ドル重量が2kgであるから評価値は2/2=1、②の品は・・・と順に算出していくと、①〜④の品を選んだときに、価値が15ドル重量が8kgであると(最適解ではないにしろ一応の)解が得られる。


=== 巡回セールスマン問題 @<fn>{shutten}
//sideimage[salesman][50mm][sep=5mm]{
ある地域の営業担当のセールスマンが、その地域に住んでいる顧客全員の家を巡回して訪ねることになったとする。巡回の順番によって移動距離が大きく変わるので、移動距離が少なくなるような巡回の方法を求めたい。
//}


//footnote[shutten][巡回セールスマン問題はimidasより、他はウィキペディアより引用・改変]






== アルゴリズムと効率性

//sideimage[sum][40mm][sep=5mm]{

ここでは、アルゴリズムの例として、1から10までの合計を求めます。
左図は「流れ図(フローチャート)」と呼ばれ、手順を示す際に良く使われます。 @<br>{}

 - 1. 「n」という名前の箱を用意し、１を入れます。
 - 2. 10 より n が大きいか、条件判断します。
 - 3. NO なら、
    「s」という名前の箱に、s + n を計算した答えを入れて、
    「n」という名前の箱に、n + 1 を計算した答えを入れます。
    そして、2 に戻ります。
 - 4. YES なら、「終了」です。
    １から10までの合計が、「s」という名前の箱に入っています。 @<br>{}

計算するための手順が「きちん」と書かれているので、確実に答えを求めることができます。

それではこのアルゴリズムの効率をみていきましょう。
1から10までの合計を求める時の計算量(足し算の回数)は10回になります。
1から100までの合計を求める時の計算量(足し算の回数)は100回になります。
1から1000までの合計を求める時の計算量(足し算の回数)は1000回になります。

このように、nに比例して計算量が増えることを、 @<code>{O(n)} と書き、 @<code>{オーダーn} と読みます。
//}
//vspace[latex][2mm]
より良いアルゴリズムとして、次のように求めることも出来ます。

//list[][]{
  (1 + n) * (n / 2) → s
//}

計算量は @<code>{O(1)}と、@<code>{n} によらず、一定の時間で計算することができ、最高に効率的です。

解きたい課題に対して複数のアルゴリズムがあります。計算速度や実装の容易さなどを思案し、良いプログラムを書いていきましょう。

===[column] カール・フリードリヒ・ガウス
後に数学王と呼ばれたガウス少年の逸話をウィキペディアより紹介します。

//vspace[latex][2mm]
//sideimage[Gauss][40mm][sep=5mm]{

ガウスが7歳の時、数学の授業で教師が「1から100までの数字すべてを足せ」という問題を出した。教師は生徒たちが問題を解くには相当な時間がかかるだろうと考えていたが、ガウスはわずか数秒で「5050」という解答を出し、教師を驚かせた。

1から100までの数字を足すと、1＋100=101、2+99=101、…、50+51=101で、101の集まりが50個できるため、101×50=5050になるとガウスは計算しました。

//blankline
19歳の時にコンパスと定規のみで正十七角形を作図できることを証明したガウスは、自身の墓碑に正十七角形を刻むよう遺言した逸話も知られています。 @<fn>{17}
//}
//blankline
その後もガウスは、素数定理や最小自乗法など赫々たる業績を挙げ、数学界に巨大な足跡を記しました。
@<br>{}

1777年 - ドイツ、ブラウンシュヴァイクに生まれる

1792年 - 素数定理の成立を予想

1795年 - 最小二乗法発見

1796年 - 平方剰余の相互法則の証明。 @<br>{}
　　　 　　コンパスと定規のみで正十七角形を作図できることを証明

1799年 - 代数学の基本定理の証明

1801年 - 『整数論の研究』出版　複素数表記、現代整数の表記導入

1801年 - 円周等分多項式の研究

1807年 - ゲッティンゲンの天文台長になり、以後40年同職につく

1809年 - 『天体運行論』出版　最小二乗法を用いたデータ補正、正規分布

1811年 - 複素積分、ガウス平面（複素数平面）ベッセルへの手紙

1827年 - 『曲面の研究』出版、微分幾何学を創始

1855年 - ゲッティンゲンで死去

//footnote[17][@<href>{http://hooktail.sub.jp/algebra/ConstructablePolygons/, 作図可能な正多角形}]


===[/column]


#@# == アルゴリズムとデータ構造
#@# TODO: 書く必要ある？　参考文献みてねでいいかも
#@# プログラム = アルゴリズム + データ構造 アルゴリズム
#@#
#@# === アルゴリズム
#@# 数学、コンピューティング、言語学、あるいは関連する分 野において、問題を解くための手順を定式化した形で表現したものを言う。「算法」と訳されることもある。
#@# 「問題」はその「解」を持っているが、アルゴリズムは正しくその解を得るための具体的手順 および根拠を与える。さらに多くの場合において効率性が重要となる。
#@#
#@# === データ構造
#@# データ構造(データこうぞう、英: data structure)は、計算機科学において、データの集まりを コンピュータの中で効果的に扱うため、一定の形式に系統立てて格納するときの形式のことで ある。
#@# ソフトウェア開発において、データ構造についてどのような設計を行うかは、プログラム(ア
#@# ルゴリズム)の効率に大きく影響する。そのため、さまざまなデータ構造が考え出されている。
#@#
#@# 基本的なデータ構造
#@#  * 配列
#@#  * スタック
#@#  * キュー
#@#  * 連想配列
#@#  * ハッシュテーブル / ルックアップテーブル 線形リスト
#@#  * 木構造
#@#  * グラフ
